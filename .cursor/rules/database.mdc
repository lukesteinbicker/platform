---
description: Tasks that require database queries using Kysely query builder with TypeScript
alwaysApply: false
globs: packages/database/**/*.{ts,tsx}
---

# Kysely Database Standards and Best Practices

This rule enforces coding standards for the `@repo/database` package using Kysely query builder with PostgreSQL (Neon/Planetscale). Covers type safety, migrations, queries, and performance optimization.

## Package Structure

```
packages/database/
├── index.ts           # Database connection and exports
├── schema.ts          # TypeScript schema definitions
└── migrations/
    ├── *.ts          # Migration files (up/down functions)
    └── run.ts        # Migration runner
```

## Schema Definition

- **TypeScript-First Approach:**
  - Define all tables as TypeScript interfaces in `schema.ts`
  - Use Kysely's type helpers: `Generated<T>`, `Insertable<T>`, `Selectable<T>`, `Updateable<T>`
  - Export typed helpers for every table (e.g., `User`, `NewUser`, `UserUpdate`)
  - Keep the `Database` interface up-to-date with all tables

```typescript
// Good: Type-safe schema definition
export interface UserTable {
  id: Generated<string>;
  email: string;
  name: string;
  created_at: Generated<Date>;
  updated_at: Generated<Date>;
}

export type User = Selectable<UserTable>;
export type NewUser = Insertable<UserTable>;
export type UserUpdate = Updateable<UserTable>;
```

## Naming Conventions

- **Database Objects:**
  - Use `snake_case` for all column names (e.g., `user_id`, `created_at`, `email_verified`)
  - Use singular nouns for table names to match TypeScript interfaces (e.g., `user`, `session`, `account`)
  - Foreign keys should be `{table}_id` (e.g., `user_id`, `company_id`)
  - Always include `id`, `created_at`, `updated_at` columns

- **TypeScript:**
  - Use `PascalCase` for table interfaces with `Table` suffix (e.g., `UserTable`)
  - Use `PascalCase` for exported types (e.g., `User`, `NewUser`)
  - Match database column names exactly in TypeScript interfaces

## Query Building

- **Type-Safe Queries:**
  - Always import and use the typed `database` instance from `@repo/database`
  - Let TypeScript infer return types; avoid manual type assertions
  - Use `.select()` to specify columns explicitly; avoid selecting all columns unless needed
  - Chain methods for readability

```typescript
// Good: Type-safe, explicit column selection
const users = await database
  .selectFrom("user")
  .select(["id", "email", "name"])
  .where("email_verified", "=", true)
  .execute();

// Bad: Selecting all columns when not needed
const users = await database
  .selectFrom("user")
  .selectAll()
  .execute();
```

- **Filters and Conditions:**
  - Use explicit comparison operators: `=`, `!=`, `>`, `<`, `>=`, `<=`, `in`, `like`
  - Use `where()` for simple conditions
  - Use `where((eb) => eb.and([...]))` or `eb.or([...])` for complex conditions
  - Prefer `whereRef()` when comparing columns

```typescript
// Good: Complex condition
const result = await database
  .selectFrom("user")
  .selectAll()
  .where((eb) => eb.and([
    eb("email_verified", "=", true),
    eb("role", "in", ["admin", "user"])
  ]))
  .execute();
```

- **Joins:**
  - Use descriptive aliases when joining tables multiple times
  - Always specify join conditions with `.on()`
  - Use appropriate join types: `innerJoin`, `leftJoin`, `rightJoin`, `fullJoin`

```typescript
// Good: Clear join with alias
const result = await database
  .selectFrom("session as s")
  .innerJoin("user as u", "u.id", "s.user_id")
  .select(["s.id", "s.expires_at", "u.email", "u.name"])
  .where("s.expires_at", ">", new Date())
  .execute();
```

## Insert, Update, Delete Operations

- **Inserts:**
  - Use `NewTable` types for insert operations
  - Use `.returning()` to get inserted data back
  - Use `.returningAll()` to return complete rows

```typescript
// Good: Type-safe insert
const newUser: NewUser = {
  email: "user@example.com",
  name: "John Doe",
  email_verified: false,
};

const insertedUser = await database
  .insertInto("user")
  .values(newUser)
  .returningAll()
  .executeTakeFirstOrThrow();
```

- **Updates:**
  - Use `TableUpdate` types for update operations
  - Always include a `where()` clause (except for intentional full table updates)
  - Use `.returning()` to verify what was updated

```typescript
// Good: Safe update with where clause
const updated = await database
  .updateTable("user")
  .set({ email_verified: true })
  .where("id", "=", userId)
  .returningAll()
  .executeTakeFirst();
```

- **Deletes:**
  - Always include a `where()` clause unless intentionally deleting all rows
  - Consider soft deletes for audit trails (add `deleted_at` column)
  - Use `.returning()` to verify what was deleted

```typescript
// Good: Safe delete with where clause
await database
  .deleteFrom("session")
  .where("expires_at", "<", new Date())
  .execute();
```

## Transaction Management

- **Use Transactions for:**
  - Multiple related operations that must succeed or fail together
  - Operations that modify multiple tables
  - Any operation requiring data consistency

```typescript
// Good: Transaction with proper error handling
const result = await database.transaction().execute(async (trx) => {
  const user = await trx
    .insertInto("user")
    .values(newUser)
    .returningAll()
    .executeTakeFirstOrThrow();

  await trx
    .insertInto("account")
    .values({ user_id: user.id, provider_id: "email" })
    .execute();

  return user;
});
```

- **Transaction Best Practices:**
  - Keep transactions short and focused
  - Avoid external API calls inside transactions
  - Handle errors appropriately (transaction auto-rolls back on error)
  - Don't nest transactions; use the passed `trx` object

## Migrations

- **Migration File Structure:**
  - Create separate migration files for each logical change
  - Export both `up` and `down` functions
  - Use descriptive filenames (e.g., `add-user-roles.ts`, `create-posts-table.ts`)

```typescript
// Good: Migration structure
export async function up(db: Kysely<Database>): Promise<void> {
  await db.schema
    .createTable("user")
    .addColumn("id", "text", (col) => col.primaryKey().notNull())
    .addColumn("email", "text", (col) => col.notNull())
    .addColumn("created_at", "timestamp", (col) =>
      col.defaultTo(sql`CURRENT_TIMESTAMP`).notNull()
    )
    .execute();
}

export async function down(db: Kysely<Database>): Promise<void> {
  await db.schema.dropTable("user").ifExists().execute();
}
```

- **Migration Best Practices:**
  - Use `.ifExists()` and `.ifNotExists()` for idempotency
  - Define foreign keys with appropriate `onDelete` and `onUpdate` actions
  - Add indexes for columns used in queries
  - Use `sql` template tag for database-specific functions
  - Test both `up` and `down` migrations

```typescript
// Good: Foreign key with cascade delete
await db.schema
  .createTable("session")
  .addColumn("id", "text", (col) => col.primaryKey().notNull())
  .addColumn("user_id", "text", (col) =>
    col.references("user.id").onDelete("cascade").notNull()
  )
  .execute();
```

## Connection Management

- **Connection Pooling:**
  - Use the singleton pattern for database connection (already implemented)
  - Export `pool` for Better Auth integration
  - Reuse the global connection in Next.js apps
  - Use `createDb()` with admin URL for migrations only

- **Environment-Specific Connections:**
  - Use `DATABASE_URL_DEV` for development
  - Use `DATABASE_URL_PROD` for production
  - Use `DATABASE_URL_{ENV}_ADMIN` for migrations (with DDL privileges)

## Query Optimization

- **Select Only Needed Columns:**
  - Use `.select([])` with explicit column list
  - Avoid `.selectAll()` in production code unless truly needed

- **Use Indexes:**
  - Add indexes in migrations for columns used in `where`, `join`, and `orderBy`
  - Consider partial indexes for filtered queries

```typescript
// In migration: Add index
await db.schema
  .createIndex("user_email_idx")
  .on("user")
  .column("email")
  .execute();
```

- **Pagination:**
  - Use `.limit()` and `.offset()` for pagination
  - Consider cursor-based pagination for large datasets
  - Always include `.orderBy()` for consistent results

```typescript
// Good: Paginated query
const users = await database
  .selectFrom("user")
  .selectAll()
  .orderBy("created_at", "desc")
  .limit(20)
  .offset(page * 20)
  .execute();
```

## Security Best Practices

- **SQL Injection Prevention:**
  - ✅ Kysely automatically prevents SQL injection with parameterized queries
  - Use the query builder methods; avoid string concatenation
  - Use `sql` template tag for raw SQL (parameterized)
  - Never interpolate user input directly into raw SQL

```typescript
// Good: Kysely prevents injection automatically
const user = await database
  .selectFrom("user")
  .selectAll()
  .where("email", "=", userInput) // Safe!
  .executeTakeFirst();

// Good: Raw SQL with parameters
const result = await database
  .selectFrom("user")
  .selectAll()
  .where(sql`LOWER(email) = LOWER(${userInput})`)
  .execute();
```

- **Sensitive Data:**
  - Never log query results containing passwords or tokens
  - Use `.select()` to exclude sensitive columns when not needed
  - Implement row-level security in queries (check user permissions)

## Error Handling

- **Kysely Error Handling:**
  - Use `.executeTakeFirstOrThrow()` when a result is required
  - Use `.executeTakeFirst()` and check for `undefined` when optional
  - Wrap operations in try-catch for custom error handling

```typescript
// Good: Proper error handling
try {
  const user = await database
    .selectFrom("user")
    .selectAll()
    .where("id", "=", userId)
    .executeTakeFirstOrThrow();
  
  return user;
} catch (error) {
  if (error instanceof NoResultError) {
    throw new Error("User not found");
  }
  throw error;
}
```

## Type Safety

- **Leverage TypeScript:**
  - Let Kysely infer types; avoid manual type assertions
  - Use `satisfies` for type checking without losing inference
  - Update `schema.ts` immediately when database structure changes
  - Run migrations before deploying schema changes

```typescript
// Good: Type inference
const user = await database
  .selectFrom("user")
  .select(["id", "email"]) // Type: { id: string; email: string }
  .where("id", "=", userId)
  .executeTakeFirst();

if (user) {
  console.log(user.email); // TypeScript knows this is a string
}
```

## Common Pitfalls

- **Don't:**
  - Forget `await` on database operations
  - Mutate query builder objects (they're immutable)
  - Use string interpolation for dynamic columns (use helpers)
  - Skip the `where()` clause on updates/deletes
  - Create connection pools manually (use the singleton)
  - Run long-running operations inside transactions

- **Do:**
  - Always handle `undefined` from `.executeTakeFirst()`
  - Use transactions for multi-step operations
  - Add indexes before querying large tables
  - Keep schema.ts and migrations in sync
  - Test migrations in development before production

## Testing

- **Database Tests:**
  - Use a separate test database
  - Run migrations before tests
  - Clean up test data after each test
  - Use transactions for test isolation when possible
